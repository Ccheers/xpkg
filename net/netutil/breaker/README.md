<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# breaker

```go
import "github.com/ccheers/xpkg/net/netutil/breaker"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Go(name string, run, fallback func() error) error](<#func-go>)
- [func Init(conf *Config)](<#func-init>)
- [type Breaker](<#type-breaker>)
- [type Config](<#type-config>)
- [type Group](<#type-group>)
  - [func NewGroup(conf *Config) *Group](<#func-newgroup>)
  - [func (g *Group) Get(key string) Breaker](<#func-group-get>)
  - [func (g *Group) Go(name string, run, fallback func() error) error](<#func-group-go>)
  - [func (g *Group) Reload(conf *Config)](<#func-group-reload>)


## Constants

```go
const (
    // StateOpen when circuit breaker open, request not allowed, after sleep
    // some duration, allow one single request for testing the health, if ok
    // then state reset to closed, if not continue the step.
    StateOpen int32 = iota
    // StateClosed when circuit breaker closed, request allowed, the breaker
    // calc the succeed ratio, if request num greater request setting and
    // ratio lower than the setting ratio, then reset state to open.
    StateClosed
    // StateHalfopen when circuit breaker open, after slepp some duration, allow
    // one request, but not state closed.
    StateHalfopen
)
```

## Variables

```go
var ErrServiceUnavailable = fmt.Errorf("service unavailable")
```

## func Go

```go
func Go(name string, run, fallback func() error) error
```

Go runs your function while tracking the breaker state of default group.

<details><summary>Example</summary>
<p>

ExampleGo this example create a default group and show function callback according to the state of breaker.

```go
package main

import (
	"fmt"

	"github.com/ccheers/xpkg/net/netutil/breaker"
)

func main() {
	run := func() error {
		return nil
	}
	fallback := func() error {
		return fmt.Errorf("unknown error")
	}
	if err := breaker.Go("example_go", run, fallback); err != nil {
		fmt.Println(err)
	}
}
```

</p>
</details>

## func Init

```go
func Init(conf *Config)
```

Init init global breaker config, also can reload config after first time call.

## type Breaker

Breaker is a CircuitBreaker pattern. FIXME on int32 atomic.LoadInt32\(&b.on\) == \_switchOn

```go
type Breaker interface {
    Allow() error
    MarkSuccess()
    MarkFailed()
}
```

<details><summary>Example</summary>
<p>

ExampleBreaker show breaker usage.

```go
package main

import (
	"fmt"

	"github.com/ccheers/xpkg/net/netutil/breaker"
)

func main() {
	// new group,use default breaker config
	g := breaker.NewGroup(nil)
	brk := g.Get("key")
	// mark request success
	brk.MarkSuccess()
	// mark request failed
	brk.MarkFailed()
	// check if breaker allow or not
	if brk.Allow() == nil {
		fmt.Println("breaker allow")
	} else {
		fmt.Println("breaker not allow")
	}
}
```

</p>
</details>

## type Config

Config broker config.

```go
type Config struct {
    SwitchOff bool // breaker switch,default off.

    // Google
    K   float64

    Window  xtime.Duration
    Bucket  int
    Request int64
}
```

## type Group

Group represents a class of CircuitBreaker and forms a namespace in which units of CircuitBreaker.

```go
type Group struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

ExampleGroup show group usage.

```go
package main

import (
	"time"

	"github.com/ccheers/xpkg/net/netutil/breaker"
	xtime "github.com/ccheers/xpkg/time"
)

func main() {
	c := &breaker.Config{
		Window:  xtime.Duration(3 * time.Second),
		K:       1.5,
		Bucket:  10,
		Request: 100,
	}
	// init default config
	breaker.Init(c)
	// new group
	g := breaker.NewGroup(c)
	// reload group config
	c.Bucket = 100
	c.Request = 200
	g.Reload(c)
	// get breaker by key
	g.Get("key")
}
```

</p>
</details>

### func NewGroup

```go
func NewGroup(conf *Config) *Group
```

NewGroup new a breaker group container, if conf nil use default conf.

### func \(\*Group\) Get

```go
func (g *Group) Get(key string) Breaker
```

Get get a breaker by a specified key, if breaker not exists then make a new one.

### func \(\*Group\) Go

```go
func (g *Group) Go(name string, run, fallback func() error) error
```

Go runs your function while tracking the breaker state of group.

### func \(\*Group\) Reload

```go
func (g *Group) Reload(conf *Config)
```

Reload reload the group by specified config, this may let all inner breaker reset to a new one.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
